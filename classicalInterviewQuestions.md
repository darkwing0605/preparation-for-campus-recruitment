
# 经典面试题

## 1.什么是盒子模型
>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。
## 2.简述一下src与href的区别
>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。

>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。
## 3.简述同步和异步的区别
>同步是阻塞模式，异步是非阻塞模式。

>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；

>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。
## 4.怎样添加、移除、移动、复制、创建和查找节点？
>1）创建新节点
```
createDocumentFragment() //创建一个DOM片段

createElement() //创建一个具体的元素

createTextNode() //创建一个文本节点
```
>2）添加、移除、替换、插入
```
appendChild() //添加

removeChild() //移除

replaceChild() //替换

insertBefore() //插入
```
>3）查找
```
getElementsByTagName() //通过标签名称

getElementsByName() //通过元素的Name属性的值

getElementById() //通过元素Id，唯一性
```
## 5.一次完整的HTTP事务是怎样的一个过程？
>基本流程：a. 域名解析

>b. 发起TCP的3次握手

>c. 建立TCP连接后发起http请求

>d. 服务器端响应http请求，浏览器得到html代码

>e. 浏览器解析html代码，并请求html代码中的资源

>f. 浏览器对页面进行渲染呈现给用户
## 6.你所了解到的Web攻击技术
>（1）XSS（Cross-Site Scripting，跨站脚本攻击）：指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。

>（2）SQL注入攻击

>（3）CSRF（Cross-Site Request Forgeries，跨站点请求伪造）：指攻击者通过设置好的陷阱，强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新。
## 7.ajax是什么?ajax的交互模型?同步和异步的区别?如何解决跨域问题？
>1. 通过异步模式，提升了用户体验

>2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用

>3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。

>Ajax的特点

>Ajax可以实现动态不刷新（局部刷新）

>readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成



>ajax的缺点

>1、ajax不支持浏览器back按钮。

>2、安全问题 AJAX暴露了与服务器交互的细节。

>3、对搜索引擎的支持比较弱。

>4、破坏了程序的异常机制。

>5、不容易调试。
## 8.什么叫优雅降级和渐进增强？
>渐进增强 progressive enhancement： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

>优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

>区别： a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带
## 9.在Javascript中什么是伪数组？如何将伪数组转化为标准数组？
>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
## 10.浏览器本地存储
>在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。

>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
## 11.线程与进程的区别
>一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
## 12.请说出三种减少页面加载时间的方法
>1.优化图片

>2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）

>3.优化CSS（压缩合并css，如margin-top,margin-left...)

>4.网址后加斜杠（如[http://www.dark-wing.com/](http://www.dark-wing.com/)目录，会判断这个“目录是什么文件类型，或者是目录。）

>5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。

>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）

>6.减少http请求（合并文件，合并图片）。
## 13.null和undefined的区别？
>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。当声明的变量还未被初始化时，变量的默认值为undefined。

>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。

>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：

>（1）变量被声明了，但没有赋值时，就等于undefined。

>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

>（3）对象没有赋值的属性，该属性的值为undefined。

>（4）函数没有返回值时，默认返回undefined。

>null表示”没有对象”，即该处不应该有值。典型用法是：

>（1） 作为函数的参数，表示该函数的参数不是对象。

>（2）作为对象原型链的终点。
## 14 .new操作符具体干了什么呢?
>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。

>2、属性和方法被加入到 this 引用的对象中。

>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
## 15 .哪些操作会造成内存泄漏？
>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。

>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。

>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
## 16.对Node的优点和缺点提出了自己的看法？
>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。

>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
## 17.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
>分为4个步骤：

>（1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。

>（2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

>（3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。

>（4），此时，Web服务器提供资源服务，客户端开始下载资源。
## 18.HTTP状态码
>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息

>200 OK 正常返回信息

>201 Created 请求成功并且服务器创建了新的资源

>202 Accepted 服务器已接受请求，但尚未处理

>301 Moved Permanently 请求的网页已永久移动到新位置。

>302 Found 临时性重定向。

>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。

>304 Not Modified 自从上次请求后，请求的网页未修改过。

>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。

>401 Unauthorized 请求未授权。

>403 Forbidden 禁止访问。

>404 Not Found 找不到如何与 URI 相匹配的资源。

>500 Internal Server Error 最常见的服务器端错误。

>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
## 19.请解释一下 JavaScript 的同源策略。
>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。
## 20 .GET和POST的区别，何时使用POST？
>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符

>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。

>然而，在以下情况中，请使用 POST 请求：

>无法使用缓存文件（更新服务器上的文件或数据库）

>向服务器发送大量数据（POST 没有数据量限制）

>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。
## 21.XHTML和HTML有什么区别
>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言

>最主要的不同：

>XHTML 元素必须被正确地嵌套。

>XHTML 元素必须被关闭。

>标签名必须用小写字母。

>XHTML 文档必须拥有根元素。
## 22.什么是语义化的HTML?
>直观的认识标签 对于搜索引擎的抓取有好处，用正确的标签做正确的事情！

>html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；

>在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。

>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
## 23.常见的浏览器内核有哪些？
>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等

>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]

## 24.HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？

>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

>绘画 canvas

>用于媒介回放的 video 和 audio 元素

>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；

>sessionStorage 的数据在浏览器关闭后自动删除

>语意化更好的内容元素，比如 article、footer、header、nav、section

>表单控件，calendar、date、time、email、url、search

>新的技术webworker, websockt, Geolocation

>移除的元素

>纯表现的元素：basefont，big，center，font, s，strike，tt，u；

>对可用性产生负面影响的元素：frame，frameset，noframes；

>支持HTML5新标签：

>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式
## 25.请描述一下 cookies，sessionStorage 和 localStorage 的区别？

>cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会

>sessionStorage和localStorage的存储空间更大；

>sessionStorage和localStorage有更多丰富易用的接口；

>sessionStorage和localStorage各自独立的存储空间；

## 26.谈谈This对象的理解。

>this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。

>但是有一个总原则，那就是this指的是调用函数的那个对象。

>this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象

## 27.谈一谈JavaScript作用域链

>当执行一段JavaScript代码（全局代码或函数）时，JavaScript引擎会创建为其创建一个作用域又称为执行上下文（Execution Context），在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。

>作用域链的作用是用于解析标识符，当函数被创建时（不是执行），会将this、arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JavaScript需要查找变量X的时候（这个过程称为变量解析），它首先会从作用域链中的链尾也就是当前作用域进行查找是否有X属性，如果没有找到就顺着作用域链继续查找，直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域链上不存在x变量，并抛出一个引用错误（ReferenceError）的异常。

## 28.如何理解JavaScript原型链

>JavaScript中的每个对象都有一个prototype属性，我们称之为原型，而原型的值也是一个对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object,它的prototype比较特殊，值为null。

>原型链的作用是用于对象继承，函数A的原型属性(prototype property)是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。

>当访问对象的一个属性时, 首先查找对象本身, 找到则返回; 若未找到, 则继续查找其原型对象的属性(如果还找不到实际上还会沿着原型链向上查找, 直至到根). 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined。

## 29..JavaScript如何实现继承？

>构造继承

>原型继承

>实例继承

>拷贝继承

>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。
```
function Parent(){

this.name = 'wang';

}



function Child(){

this.age = 28;

}

Child.prototype = new Parent();//继承了Parent，通过原型

var demo = new Child();

alert(demo.age);

alert(demo.name);//得到被继承的属性
```

## 30.清除浮动有哪些方式？比较好的方式是哪一种？

>（1）父级div定义height。

>（2）结尾处加空div标签clear:both。

>（3）父级div定义伪类:after和zoom。

>（4）父级div定义overflow:hidden。

>（5）父级div定义overflow:auto。

>（6）父级div也浮动，需要定义宽度。

>（7）父级div定义display:table。

>（8）结尾处加br标签clear:both。

>比较好的是第3种方式，好多网站都这么用。

## 31.box-sizing常用的属性有哪些？分别有什么作用？

>(Q1)box-sizing: content-box|border-box|inherit;

>(Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。

>border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。

## 32.Doctype作用？标准模式与兼容模式各有什么区别?

>(Q1)<!DOCTYPE>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。

>(Q2)标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。

## 33.HTML5 为什么只需要写 <!DOCTYPE HTML>？

>HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。

>而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。

## 34.页面导入样式时，使用link和@import有什么区别？

>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;

>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;

>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。

## 35.介绍一下你对浏览器内核的理解？

>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。

>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

>JS引擎则：解析和执行javascript来实现网页的动态效果。

>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

## 36.IE和DOM事件流的区别

>1执行顺序不一样

>2参数不一样

>3事件加不加on

>4this指向问题

## 37.哪些地方会出现css阻塞，哪些地方会出现js阻塞？

>js 的阻塞特性：所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。

>由于浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。

>CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。

>根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。

## 38.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?

>标签选择符 类选择符 id选择符

>继承不如指定 Id>class>标签选择

>后者优先级高

## 39.在JavaScript我们会遇到闭包，请你们根据自己的理解分析一下什么是闭包？闭包有什么好处？使用闭包要注意什么？

>闭包：函数嵌套函数，内部函数可以引用外部函数的参数和变量，变量和参数不会被垃圾回收机制所回收

>好处：（1）希望一个变量长期驻扎在内存之中

>（2）避免全局变量的污染

>（3）私有成员的存在

>注意：可能会造成内存泄漏

## 40.如何阻止事件冒泡和默认事件（程序）
```
function stopBubble(e)

{

if (e && e.stopPropagation)

e.stopPropagation()

else

window.event.cancelBubble=true

}

return false
```
 ## 41.querySelector系列方法与getElementsBy系列方法对比有什么不同？
 >（1）两者的W3C标准不同
 
 >querySelector系列属于W3C中的Selector API规范
 
 >getElementsBy系列则属于W3C的DOM规范
 
 
>（2）两者浏览器的兼容不同

>querySelector系列基本能被所有浏览器支持（Firefox某个版本不支持）

>getElementsBy系列则同城只有在考虑兼容性的时候才被提起（尽管两者功能相近）


>（3）接受参数不同

>querySelector系列接收的参数是一个CSS选择器名

>getElementBy系列接收的参数只能是单一的className、tagName和name


>（4）返回值不同

>querySelectorAll()返回的是一个静态节点列表（Static NodeList）

>getElementsBy系列返回的是一个动态节点列表（Live NodeList）
```
var ul = document.querySelectorAll('ul')[0];
var list = ul.querySelectorAll('li');
for (var i = 0; i < list.length; i++){
    ul.appendChild(document.createElement('li'));
}
```

```
//这是个死循环
var ul = document.getElementsByTagName('ul')[0];
var list = ul.getElementsByTagName('li');
    /*
    //↓避免出现死循环
    //var changdu = list.length;
    */
for (var i = 0; i < list.length; i++){
    ul.appendChild(document.createElement('li'));
}
```
